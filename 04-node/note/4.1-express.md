# express

#### introduction

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */

1) express              // 生态圈相较完整

    npm i express

2) koa2                 // 接口更丰富，友好

3) ...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * http module
 * 
 * 
 * 1) 根据不同的请求路径，请求方法，做不同的事情，处理起来比较麻烦
 * 2) 读取请求体和写入响应体是通过流的方式，比较麻烦
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### express basic

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 配置请求映射，根绝不同的请求( 若请求方法和路径均满足后 )，匹配不同的处理函数
 *
 *
 * const app = express();
 * app.method(path, fn);
 */

/**
 * REST STYLE API
 *
 *
 * /api/test    post        根据不同方法执行不同的请求
 *              get
 *              put
 *              delete
 *              ...
 *
 *              all                     匹配所有方法
 *
 *              all('*', ()=>{});       匹配所有路径
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### nodemon

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * nodemon              // 监听文件变化， 当文件内容发生改变时自动更新并重新执行文件
 *
 *
 * npm i -D nodemon
 *
 ** 利用 nodemon.json 扩展细节配置
 */

npx nodemo index.js

// package.json

"scripts": {
    "start": "nodemon --x npm run server",
    "server": "node index"
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### express middleware

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * app.method(path, (req,res,next)=>{} ...);
 *
 * @ (req,res,next)=>{}
 *      - request: 请求
 *      - response: 响应
 *      - next: 手动触发，将当前中间件的结果递交给下一个中间件
 *
 ** 1) 匹配 path
 *
 *      a) 匹配成功
 *
 *          依次交给中间件处理( 中间件中需要手动调用 next(); 后才可以递交给后续中间件处理 )
 *
 *      b) 中间件细节
 *
 *          若递交后，已无后续中间件( express 发现响应无结果，则会响应 404 )
 *
 *      c) 匹配失败
 *
 *          不会停止服务器
 *          相当于调用 next(errObj);
 *          寻找后续错误处理中间件( 若无错误处理中间件，则响应 status: 500 )
 */

                  Request
                     |
        + ------------------------- +
        |                           |
        |    exprress_middleware    | --->  response
        |                           |
        + ------------------------- +
                     |
                    \|/
        + ------------------------- +
        |                           |
        |    exprress_middleware    | --->  response
        |                           |
        + ------------------------- +
                     |
                    \|/
        + ------------------------- +
        |                           |
        |         ... ...           |
        |                           |
        + ------------------------- +
                     |


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### express inner middleware

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * express.static();
 * 
 * 
 * 自动响应并返回 静态资源
 * 
 ** 默认情况: 若 staticPath 为目录，则读取 index.html 作为索引文件
 */

// 当请求时，根据请求路径，从指定的目录中寻找是否存在该文件

    1) 存在: 直接响应文件，不再交给后续的中间件处理
    
    2) 不存在: 直接移交给后续中间件处理( 调用 next(); )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * express.urlencoded(options);
 * 
 * 
 * 用于解析 'application/x-www-form-urlencoded' 格式的消息体
 */


需要开启

options: {

    extended: true,             // 支持更丰富的编码形式
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * express.json();
 * 
 * 
 * 用于解析 'json' 格式的消息体
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### express-cookie

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * cookie middleware
 * 
 * 
 * 
 */

npm i cookie-parser


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/** 理论上 **/

// 假设服务器有一个接口，通过请求该接口，可以添加一个管理员
// 但不是任何人都有权力做这种操作
// 服务器是如何知道请求接口的人的权力的呢？

答案: 只有登陆过的管理员才有权力执行该操作


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 问题: 客户端与服务器的传输使用的是 "http/https 协议( 该协议无状态 )"
//      服务器无法判断这次请求和之前请求成功的人是否为同一个人

由于 http/https 协议无状态，服务器无法判断当前请求和之前请求的客户端是否为同一个客户端


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 解决 http/https 协议无状态

1) 客户端登陆成功后，服务器会给客户端一个 "出入证"

2) 后续客户端的每次请求，都必须要附带这个 "出入证"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// cookie 的产生

用户登陆不同的网站，还会收到服务器给予的多个 "出入证"，因此客户端需要一个类似卡包的东西:

1) 能够存放多个出入证: 

    可能来自多个网站
    也可能是一个网站中的多个出入证

2) 能够自动出示出入证:

    当客户端访问不同网站时，能自动吧对应的出入证附带请求发送出去

3) 正确的出示出入证:

    客户端不能将肯德基的出入证发送给麦当劳

4) 管理出入证的有效期:

    客户端能够检查已过期的出入证，并从卡包中移除


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// cookie 的组成

key         // 键

value       // 值

domain      // 域名

path        // 域名下的路径

secure      // 是否安全传输

expire      // 过期时间


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 当 cookie 同时满足以下条件时，则会被附带到请求中

1) cookie 未过期

2) cookie.domain === requset.domain;            // 域名一致即可，忽略端口

3) cookie.path === request.path;                // 可匹配当前 path 及 以 /path/... 为根路径的后代路径

4) cookie.secure === true ? https : http;       // 是否开启安全传输


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 如何设置 cookie
 * 
 * 
 * 由于 cookie 是保存在浏览器端，同时很多证件又是服务器端颁发的
 */


// 服务器响应

当服务器哥诶客户端颁发一个证件时，会在响应消息中包含 cookie，浏览器会自动的吧 cookie 保存到卡包中


// 客户端自行设置

该情况较少，(例如: 用户关闭某个广告，并选择"以后不再弹出") 该种情况会通过浏览器的JS代码保存到 cookie 中
后续请求服务器时，服务器会看到客户端不想再次弹出广告的 cookie，则不会再发送广告过来


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 服务器端设置 cookie
 * 
 * 
 * 服务器端可通过设置响应头，来设置浏览器中的 cookie
 * 
 ** 浏览器会自动将 cookie 保存到卡包中，若卡包中已存在 "相同卡片( key, path, domain 相同 )"，则自动覆盖该卡片之前的配置
 */


// 可根据需求，在一次响应中设置多个 cookie

set-cookie: cookie_01
set-cookie: cookie_02
set-cookie: cookie_03
... ...


// cookie 格式如下( key=val 是必须设置的，其他属性为可选属性，并且顺序不限 )

key=val; ?path=''; ?domain=''; ?expire=''; ?max-age=''; secure=''; ?httponly='';


/** 必填配置 **/

key=val;


/** 可选配置 **/

path:               // 默认当前请求中的 路径

domain:             // 默认当前请求中的 域名

// 回话结束后过期: 对于即没有设置 expire & max-age 的请求

expire:             // 设置 cookie 的过期时间( 必须为有效的 GMT 时间 )，当到达过期时间，客户端会自动销毁该 卡片

max-age:            // 设置 cookie 的相对有效期( expire & max-age 仅设置一个即可 )
                    // eg: max-age: 1000; 则 cookie 到期时间为 expire + 1000 为最终到期时间

secure:             // 设置 cookie 是否是安全链接
                    // 若设置该值，则表示该 cookie 后续只能随着 https 请求发送
                    // 若不设置，则表示 cookie 会随着所有请求发送

httponly:           // 设置 httponly 是否技能用于传输
                    // 若设置该值，表示该 cookie 仅能用于传输，而不允许在客户端通过 JS 截获，防止跨站脚本攻击( XSS )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 客户端设置 cookie
 * 
 * 
 ** 若设置了 httponly，则无法通过 document.cookie 设置 cookie
 ** path&domain默认值: 在客户端设置 coookie 时，也许根本未发生请求，path 在客户端设置时的默认值是当前网页的path
 */


document.cookie = 'key=val; key=val; ?path=''; ?domain=''; ?expire=''; ?max-age=''; secure=''; ?httponly='';'


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 无论是 客户端 还是 服务器，删除 cookie
 * 
 * 
 * 修改过期时间即可
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### 断点调试

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * node --inspect           // 该进程会监听 9229 端口
 * 
 * 
 * 当使用该种方式打开 index 文件时，可在浏览器中打断点调试
 */

node --inspect index


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### JSONP

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 同源策略
 * 
 * 
 * 
 */





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```












